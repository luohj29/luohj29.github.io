<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="Rogers | learning in cs and math">
    <meta name="keywords" content="Rogers, luohj29, blog, cs, math, sysu,ML,Photography">
    <meta name="theme-color" content="#000000">

    <!-- Open Graph -->
    
    <meta property="og:title"
                content="OS lab7 实现虚拟内存的内存管理 - RogersLuo">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="
">
    
    <meta property="article:published_time" content=" 2024-06-04T00:00:00Z">
    
    
    
    <meta property="article:tag" content="OS">
    
    
    <meta property="og:image" content="http://localhost:4000/img/Rogers.png">
    <meta property="og:url" content="http://localhost:4000/2024-06-04-OS-lab7/">
    <meta property="og:site_name" content="RogersLuo">

    <title>OS lab7 实现虚拟内存的内存管理 - RogersLuo</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">

    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/2024-06-04-OS-lab7/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href=" /css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href=" /css/hux-blog.min.css">

    

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet"
        type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->

    <!-- diffBackground -->
    <script type="text/javascript">
        function diffBackground() {
            datetoday = new Date();
            timenow = datetoday.getTime();
            datetoday.setTime(timenow);
            thehour = datetoday.getHours();
            if (thehour >= 15 && thehour < 18)
                display = "img/index-bg.jpg";
            else if (thehour >= 18 && thehour < 21)
                display = "img/index-bg-night.jpg";
            else if (thehour >= 21 && thehour < 24)
                display = "img/home-bg-star_track.jpg";
            else if (thehour >= 0 && thehour < 3)
                display = "img/home-bg-star_track.jpg";
            else if (thehour >= 3 && thehour < 6)
                display = "img/index-bg-night.jpg";
            else if (thehour >= 6 && thehour < 12)
                display = "img/index-bg.jpg";
            else if (thehour >= 12 && thehour < 15)
                display = "img/index-bg.jpg";
            else
                display = "img/index-bg.jpg";

            var css = '<style type="text/css">';
            css += 'header.intro-header{background-image: url(\'/' + display + '\');}';
            css += '</style>';
            document.write(css);
        }
    </script>

</head>

<!-- hack iOS CSS :active style -->

<body ontouchstart="">

    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/blog">RogersLuo's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    <li>
                        <a href="/blog">Blog</a>
                    </li>
                    <li>
                        <a href="/archive">Archive</a>
                    </li>
                    <!-- 
                    
                    
                    
                    
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    
                    
                    <li>
                        <a href="/archive/">Archive</a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                     -->
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/index-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->





    
    <style type="text/css">
        header.intro-header{
            position: relative;
            background-image: url('/img/index-bg.jpg');
            background: ;
        }

        
    </style>
    
    
        
    <header class="intro-header" >
        
    
    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=OS" title="OS">OS</a>
                        
                    </div>
                    <h1 >OS lab7 实现虚拟内存的内存管理</h1>
                    
                    <h2 class="subheading" ></h2>
                    <span class="meta">Posted by RogersLuo's Blog on June 4, 2024</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    
        <div class="container">
            
            <div class="row">

                <!-- Post Container -->
                <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                    <!-- Multi-Lingual -->
                    

                    <p><img src="..\img\in-post\image-20240315232430405.png" alt="image-20240315232430405" /></p>

<h1 id="本科生实验报告"><strong>本科生实验报告</strong></h1>

<p>实验课程: 操作系统</p>

<p>任课教师: 刘宁</p>

<p>实验题目:内存管理</p>

<p>专业名称: 信息与计算科学</p>

<p>学生姓名:罗弘杰</p>

<p>学生学号: 22336173</p>

<p>实验地点: 实验中心D503</p>

<p>实验时间: 2024/3/15</p>

<h2 id="section-1-实验概述"><strong>Section 1 实验概述</strong></h2>

<p>在本次实验中，我们首先学习如何使用<strong>位图和地址池来</strong>管理资源。然后，我们将<strong>实现在物理地址空间下的内存管理。</strong>接着，我们将会学习并<strong>开启二级分页机制</strong>。在开启分页机制后，我们将<strong>实现在虚拟地址空间下的内存管理。</strong></p>

<p>本次实验最精彩的地方在于分页机制。基于分页机制，我们可以将连续的虚拟地址空间映射到不连续的物理地址空间。同时，对于同一个虚拟地址，在不同的页目录表和页表下，我们会得到不同的物理地址。这为实现虚拟地址空间的隔离奠定了基础。但是，本实验最令人困惑的地方也在于分页机制。开启了分页机制后，程序中使用的地址是虚拟地址。我们需要结合页目录表和页表才能确定虚拟地址对应的物理地址。而我们常常会忘记这一点，导致了我们不知道某些虚拟地址表示的具体含义。</p>

<h2 id="section-2-预备知识与实验环境"><strong>Section 2 预备知识与实验环境</strong></h2>

<p>略</p>

<h2 id="section-3-实验任务"><strong>Section 3 实验任务</strong></h2>

<h3 id="实验任务1">实验任务1：</h3>

<p>复现实验7指导书中“物理页内存管理”一节的代码，实现物理页内存的管理，</p>

<p>具体要求如下：</p>

<ol>
  <li>结合代码分析位图，地址池，物理页管理的初始化过程，以及物理页进行分配和释放的实现 思路。</li>
  <li>构造测试用例来分析物理页内存管理的实现是否存在bug。如果存在，则尝试修复并再次测 试。否则，结合测试用例简要分析物理页内存管理的实现的正确性。</li>
</ol>

<p>复现“二级分页机制”一节的代码，结合代码来分析我们开启分页机制的三步方案、</p>

<h3 id="实验任务2">实验任务2：</h3>

<p>复现实验7指导书中“二级分页机制”一节的代码，实现二级分页机制，具体要求如下：</p>

<ol>
  <li>实现内存的申请和释放，保存实验截图并对能够在虚拟地址空间中进行内存管理，截图并给 出过程解释（比如：说明哪些输出信息描述虚拟地址，哪些输出信息描述物理地址）。注 意：建议使用的物理地址或虚拟地址信息与学号相关联（比如学号后四位作为页内偏移）， 作为报告独立完成的个人信息表征。</li>
  <li>相比于一级页表，二级页表的开销是增大了的，但操作系统中往往使用的是二级页表而不是 一级页表。结合你自己的实验过程，说说相比于一级页表，使用二级页表会带来哪些优势。</li>
</ol>

<h3 id="实验任务3">实验任务3：</h3>

<p>复现“虚拟页内存管理”一节的代码，完成如下要求。</p>

<ul>
  <li>结合代码分析虚拟页内存分配的三步过程和虚拟页内存释放。</li>
  <li>构造测试例子来分析虚拟页内存管理的实现是否存在bug。如果存在，则尝试修复并再次测试。否则，结合测例简要分析虚拟页内存管理的实现的正确性。</li>
  <li>在pde（页目录项）和pte（页表项）的虚拟地址构造中，我们使用了第1023个页目录项。第1023个页目录项指向了页目录表本身，从而使得我们可以构造出pde和pte的虚拟地址。现在，我们将这个指向页目录表本身的页目录项放入第1000个页目录项，而不再是放入了第1023个页目录项。然后，同学们需要借助于这个第1000个页目录项，构造出第141个页目录项的虚拟地址和第891个页目录项指向的页表中的第109个页表项的虚拟地址。</li>
</ul>

<h3 id="实验任务4">实验任务4：</h3>

<p>选做内容，如果完成，可附加实验完成度评分）在Assignment 3的基础上，实现一种理论课上 学习到的虚拟内存管理中的页面置换算法，在虚拟页内存中实现页面的置换，比如下面所列算法 的其中一种:</p>

<ol>
  <li>先进先出页面置换(FIFO).</li>
  <li>最优页面置换(OPR).</li>
  <li>最近最少使用页面置换(LRU)</li>
  <li>最不经常使用页面置换(LFU)。</li>
</ol>

<p>上述置换算法的细节参见理论课教材(《操作系统概念》，原书第9版，中文)第272-280页，你也 可以实现一种自己设计的置换算法。要求:描述你的设计思路并展示页面置换结果的截图(也可以统计缺页错误发生的次数作为输出）。</p>

<h2 id="section-4-实验步骤与实验结果"><strong>Section 4 实验步骤与实验结果</strong></h2>

<p>​</p>

<h3 id="--实验任务1-">————————- 实验任务1————————-</h3>

<h4 id="任务要求">任务要求：</h4>

<p>​	复现实验7指导书中“物理页内存管理”一节的代码，实现物理页内存的管理，</p>

<p>具体要求如下：</p>

<ol>
  <li>结合代码分析位图，地址池，物理页管理的初始化过程，以及物理页进行分配和释放的实现 思路。</li>
  <li>构造测试用例来分析物理页内存管理的实现是否存在bug。如果存在，则尝试修复并再次测 试。否则，结合测试用例简要分析物理页内存管理的实现的正确性。</li>
  <li>（不强制要求，对实验完成度评分无影响）如果你有想法，可以在自己的理解的基础上，参 考ucore，《操作系统真象还原》，《一个操作系统的实现》等资料来实现自己的物理页内 存管理。在完成之后，你需要指明相比指导书，你实现的物理页内存管理的特点。</li>
</ol>

<h4 id="代码分析">代码分析</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">BitMap</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// 被管理的资源个数，bitmap的总位数</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
    <span class="c1">// bitmap的起始地址</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="c1">// 初始化</span>
    <span class="n">BitMap</span><span class="p">();</span>
    <span class="c1">// 设置BitMap，bitmap=起始地址，length=总位数(即被管理的资源个数)</span>
    <span class="kt">void</span> <span class="n">initialize</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span><span class="p">);</span>
    <span class="c1">// 获取第index个资源的状态，true=allocated，false=free</span>
    <span class="kt">bool</span> <span class="n">get</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">// 设置第index个资源的状态，true=allocated，false=free</span>
    <span class="kt">void</span> <span class="n">set</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">status</span><span class="p">);</span>
    <span class="c1">// 分配count个连续的资源，若没有则返回-1，否则返回分配的第1个资源单元序号</span>
    <span class="kt">int</span> <span class="n">allocate</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
    <span class="c1">// 释放第index个资源开始的count个资源</span>
    <span class="kt">void</span> <span class="n">release</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
    <span class="c1">// 返回Bitmap存储区域</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">getBitmap</span><span class="p">();</span>
    <span class="c1">// 返回Bitmap的大小</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="nl">private:</span>
    <span class="c1">// 禁止Bitmap之间的赋值</span>
    <span class="n">BitMap</span><span class="p">(</span><span class="k">const</span> <span class="n">BitMap</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">BitMap</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">AddressPool</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">BitMap</span> <span class="n">resources</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">startAddress</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">AddressPool</span><span class="p">();</span>
    <span class="c1">// 初始化地址池，参数为位图的起始地址，长度，以及地址池的开始地址</span>
    <span class="kt">void</span> <span class="n">initialize</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span><span class="k">const</span> <span class="kt">int</span> <span class="n">startAddress</span><span class="p">);</span>
    <span class="c1">// 从地址池中分配count个连续页，成功则返回第一个页的地址，失败则返回-1</span>
    <span class="kt">int</span> <span class="n">allocate</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
    <span class="c1">// 释放若干页的空间</span>
    <span class="kt">void</span> <span class="n">release</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">address</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">);</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>
<span class="k">class</span> <span class="nc">MemoryManager</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// 可管理的内存容量</span>
    <span class="kt">int</span> <span class="n">totalMemory</span><span class="p">;</span>
    <span class="c1">// 内核物理地址池</span>
    <span class="n">AddressPool</span> <span class="n">kernelPhysical</span><span class="p">;</span>
    <span class="c1">// 用户物理地址池</span>
    <span class="n">AddressPool</span> <span class="n">userPhysical</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">MemoryManager</span><span class="p">();</span>

    <span class="c1">// 初始化地址池</span>
    <span class="kt">void</span> <span class="n">initialize</span><span class="p">();</span>

    <span class="c1">// 从type类型的物理地址池中分配count个连续的页</span>
    <span class="c1">// 成功，返回起始地址；失败，返回0</span>
    <span class="kt">int</span> <span class="n">allocatePhysicalPages</span><span class="p">(</span><span class="k">enum</span> <span class="n">AddressPoolType</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

    <span class="c1">// 释放从paddr开始的count个物理页</span>
    <span class="kt">void</span> <span class="n">releasePhysicalPages</span><span class="p">(</span><span class="k">enum</span> <span class="n">AddressPoolType</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">paddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>

    <span class="c1">// 获取内存总容量</span>
    <span class="kt">int</span> <span class="n">getTotalMemory</span><span class="p">();</span>

<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>​	可以看到这三个类是由底层到高层的关系，在初始化的时候内存管理器的初始化函数，会计算一些关键的参数（位图的起始，地址空间的页数，地址空间的开始），然后调用地址池的初始函数，地址池的初始化函数除了规定该地址池的起始地址，还会初始化该地址处的位图，调用位图的初始化函数，其中，位图的初始化函数会计算页数所需要的位图的大小，然后调用Memset在其起始地址开辟一定大小的空间</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="c1">// 内存管理器的初始化函数</span>
    <span class="kt">int</span> <span class="n">usedMemory</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="mh">0x100000</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">totalMemory</span> <span class="o">&lt;</span> <span class="n">usedMemory</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"memory is too small, halt.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">asm_halt</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="c1">// 剩余的空闲的内存</span>
    <span class="kt">int</span> <span class="n">freeMemory</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">totalMemory</span> <span class="o">-</span> <span class="n">usedMemory</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">freePages</span> <span class="o">=</span> <span class="n">freeMemory</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">kernelPages</span> <span class="o">=</span> <span class="n">freePages</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">//计算可用的物理页的页数，平均分为内核空间和进程空间</span>
    <span class="kt">int</span> <span class="n">userPages</span> <span class="o">=</span> <span class="n">freePages</span> <span class="o">-</span> <span class="n">kernelPages</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">kernelPhysicalStartAddress</span> <span class="o">=</span> <span class="n">usedMemory</span><span class="p">;</span>  <span class="c1">//地址池的开始地址，也就是物理空间的起始</span>
    <span class="kt">int</span> <span class="n">userPhysicalStartAddress</span> <span class="o">=</span> <span class="n">usedMemory</span> <span class="o">+</span> <span class="n">kernelPages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">kernelPhysicalBitMapStart</span> <span class="o">=</span> <span class="n">BITMAP_START_ADDRESS</span><span class="p">;</span>  <span class="c1">//位图开始地址</span>
    <span class="kt">int</span> <span class="n">userPhysicalBitMapStart</span> <span class="o">=</span> <span class="n">kernelPhysicalBitMapStart</span> <span class="o">+</span> <span class="n">ceil</span><span class="p">(</span><span class="n">kernelPages</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

    <span class="n">kernelPhysical</span><span class="p">.</span><span class="n">initialize</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">kernelPhysicalBitMapStart</span><span class="p">,</span> <span class="n">kernelPages</span><span class="p">,</span> <span class="n">kernelPhysicalStartAddress</span><span class="p">);</span>
    <span class="n">userPhysical</span><span class="p">.</span><span class="n">initialize</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">userPhysicalBitMapStart</span><span class="p">,</span> <span class="n">userPages</span><span class="p">,</span> <span class="n">userPhysicalStartAddress</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">// 地址池的初始化函数</span>
<span class="kt">void</span> <span class="n">AddressPool</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">startAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">resources</span><span class="p">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">startAddress</span> <span class="o">=</span> <span class="n">startAddress</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c1">//位图的初始化函数</span>
<span class="kt">void</span> <span class="n">BitMap</span><span class="o">::</span><span class="n">initialize</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">bitmap</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span> <span class="c1">//每一个字节对应一个页数，所以要计算除以8的天花板</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">bitmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>物理页分配和释放：</p>

<p>​	由于分配和释放几乎是类似而相反的操作，所以以下只分析分配的代码</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="rouge-code"><pre><span class="c1">//内存管理器的分配函数，参数是地址空间的类型，需要的页数（页内存管理）</span>
<span class="kt">int</span> <span class="n">MemoryManager</span><span class="o">::</span><span class="n">allocatePhysicalPages</span><span class="p">(</span><span class="k">enum</span> <span class="n">AddressPoolType</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">kernelPhysical</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">count</span><span class="p">);</span> <span class="c1">//调用该地址池的分配函数</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AddressPoolType</span><span class="o">::</span><span class="n">USER</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">userPhysical</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 从地址池中分配count个连续页</span>
<span class="kt">int</span> <span class="n">AddressPool</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">uint32</span> <span class="n">start</span> <span class="o">=</span> <span class="n">resources</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>  <span class="c1">//查看位图中的记录，是否存在这样连续的内存页</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="p">(</span><span class="n">start</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="n">startAddress</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">//位图的分配函数</span>
<span class="kt">int</span> <span class="n">BitMap</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">start</span><span class="p">;</span>

    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 越过已经分配的资源</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="o">++</span><span class="n">index</span><span class="p">;</span>

        <span class="c1">// 不存在连续的count个资源</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">length</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="c1">// 找到1个未分配的资源</span>
        <span class="c1">// 检查是否存在从index开始的连续count个资源</span>
        <span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">empty</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="o">++</span><span class="n">empty</span><span class="p">;</span>
            <span class="o">++</span><span class="n">index</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 存在连续的count个资源</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">empty</span> <span class="o">==</span> <span class="n">count</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">set</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">start</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>​	总的来说，内存管理器会根据内存空间的类型调用地址池的内存分配函数，在地址池中，位图实际上是用来记录页数是否已经分配，分配了置为1，没分配置为0，所以查看位图中是否存在这样数量的连续内存页就可以确定是否可以分配，可以的话， 通过计算位图中的index*pagesize+startaddress就可以正确来到可以满足要求的地址开始位置。</p>

<h4 id="测试分析">测试分析</h4>

<h5 id="测试代码">测试代码：</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">first_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//测试地址管理器是否正常工作</span>
    <span class="n">uint32</span> <span class="n">a</span> <span class="o">=</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePhysicalPages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">USER</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">uint32</span> <span class="n">b</span> <span class="o">=</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePhysicalPages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">USER</span><span class="p">,</span> <span class="mi">16000</span><span class="p">);</span><span class="o">/</span>
    <span class="n">uint32</span> <span class="n">c</span> <span class="o">=</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePhysicalPages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">uint32</span> <span class="n">d</span> <span class="o">=</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePhysicalPages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">16000</span><span class="p">);</span>
    <span class="n">uint32</span> <span class="n">e</span> <span class="o">=</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePhysicalPages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">USER</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"trying to allocate 3 page in USER space and succeed at a: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"trying to allocate 16000 page in USER space and fail from b: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"trying to allocate 1 page in KERNEL space and succeed at c: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"trying to allocate 16000 page in kERNEL space and fail from d: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"trying to allocate 2 page in USER space and succeed at e: %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
    <span class="n">asm_halt</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="实验结果">实验结果：</h5>

<p>​	可以看到地址返回都是正确的，而且可以判断页数是否足够，不足够的话就不会分配，在下一侧分配的时候，<strong>根据连续内存分配的法则，会接着最近的可用地址空间来分配（由最后一个测试分配可以看出）。</strong></p>

<p><img src="..\img\in-post\image-20240520215639922.png" alt="image-20240520215639922" /></p>

<h3 id="--实验任务2-">————————- <strong>实验任务2</strong>————————-</h3>

<h4 id="任务要求-1">任务要求：</h4>

<p>复现实验7指导书中“二级分页机制”一节的代码，实现二级分页机制，具体要求如下：</p>

<ol>
  <li>实现内存的申请和释放，保存实验截图并对能够在虚拟地址空间中进行内存管理，截图并给 出过程解释（比如：说明哪些输出信息描述虚拟地址，哪些输出信息描述物理地址）。注 意：建议使用的物理地址或虚拟地址信息与学号相关联（比如学号后四位作为页内偏移）， 作为报告独立完成的个人信息表征。</li>
  <li>相比于一级页表，二级页表的开销是增大了的，但操作系统中往往使用的是二级页表而不是 一级页表。结合你自己的实验过程，说说相比于一级页表，使用二级页表会带来哪些优势。</li>
</ol>

<h4 id="思路分析">思路分析：</h4>

<p>​	本实验在32位实模式下进行，具有32位地址空间，设计的二级分页机制为，1个页目录具有1024个页表项（大小为4B），每一个页表项有1024个物理页（大小也为4B）,每一个物理页大小为4KB.</p>

<p>​	由此1024* 1024*4KB = 32GB, 恰好是32位的地址空间， 高10位负责在页目录中缺点页目录项， 中10位负责在页表项中确定物理页的序号，最后12位是在该物理页中的偏移地址。</p>

<p>​	地址转换过程：</p>

<ol>
  <li>给定一个虚拟地址，先取31-22位，其数值乘4后得到页目录表项在页目录表的偏移地址。这个偏移地址加上页目录表的物理地址后得到页目录项的物理地址。</li>
  <li>取页目录项中的内容，得到页表的物理地址。页表的物理地址加上21-12位乘4的结果后，得到页表项的物理地址。</li>
  <li>取页表项的内容，即物理页的物理地址，加上11-0位的内容后便得到实际的物理地址。</li>
</ol>

<h4 id="实验步骤">实验步骤：</h4>

<p>开启二级分页的3个步骤：</p>

<ol>
  <li>规划好页目录表和页表在内存中的位置，然后初始化。</li>
  <li>将页目录表的地址写入cr3。</li>
  <li>将cr0的PG位置1。</li>
</ol>

<p><strong>第一步，规划好页目录表和页表在内存中的位置并写入内容：</strong></p>

<p>首先，我们需要明确一点，页目录表和页表是需要在内存中特意地划分出位置来存放的。所以，我们需要在内存中指定页目录表和页表存放的位置。同时，页目录表和页表的物理地址必须是4KB的整数倍，也就是低12位为0。</p>

<p>规定了页目录表的位置后，我们根据线性地址空间的大小来确定需要分配的页表的数量和位置，不必一开始就分配完1024个页表给页目录表。规划好了页目录表的位置后，我们向页目录表中写入页表对应的页目录项。页目录项的结构如下。</p>

<p>​		开始地址规划：0~1MB将会是内核代码段，其中我们会简单地使用恒等映射将物理页化为虚拟页，然后页目录会在1MB开始，</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre><span class="cp">#define PAGE_DIRECTORY 0x100000  //
</span><span class="kt">void</span> <span class="n">MemoryManager</span><span class="o">::</span><span class="n">openPageMechanism</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 页目录表指针</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">directory</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">PAGE_DIRECTORY</span><span class="p">;</span>
    <span class="c1">//线性地址0~4MB对应的页表</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">PAGE_DIRECTORY</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

    <span class="c1">// 初始化页目录表</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
    <span class="c1">// 初始化线性地址0~4MB对应的页表</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 将线性地址0~1MB恒等映射到物理地址0~1MB</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// U/S = 1, R/W = 1, P = 1</span>
        <span class="n">page</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">address</span> <span class="o">|</span> <span class="mh">0x7</span><span class="p">;</span>
        <span class="n">address</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 初始化页目录项</span>

    <span class="c1">// 0~1MB</span>
    <span class="n">directory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">page</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x07</span><span class="p">;</span>
    <span class="c1">// 3GB的内核空间</span>
    <span class="n">directory</span><span class="p">[</span><span class="mi">768</span><span class="p">]</span> <span class="o">=</span> <span class="n">directory</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="c1">// 最后一个页目录项指向页目录表</span>
    <span class="n">directory</span><span class="p">[</span><span class="mi">1023</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">directory</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x7</span><span class="p">;</span>

    <span class="c1">// 初始化cr3，cr0，开启分页机制</span>
    <span class="n">asm_init_page_reg</span><span class="p">(</span><span class="n">directory</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"open page mechanism</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>第二步： 将页目录表的地址写入cr3寄存器；</p>

<p>第三步，将cr0的PG位置1</p>

<p>​	这两步通过汇编函数执行</p>

<pre><code class="language-asm">asm_init_page_reg:
    push ebp
    mov ebp, esp

    push eax

    mov eax, [ebp + 4 * 2]
    mov cr3, eax ; 放入页目录表地址
    mov eax, cr0
    or eax, 0x80000000
    mov cr0, eax           ; 置PG=1，开启分页机制

    pop eax
    pop ebp

    ret
</code></pre>

<h4 id="实验结果-1">实验结果：</h4>

<ol>
  <li>
    <p>实现内存的申请和释放，保存实验截图并对能够在虚拟地址空间中进行内存管理，截图并给 出过程解释（比如：说明哪些输出信息描述虚拟地址，哪些输出信息描述物理地址）。注 意：建议使用的物理地址或虚拟地址信息与学号相关联（比如学号后四位作为页内偏移）， 作为报告独立完成的个人信息表征。</p>

    <p><img src="..\img\in-post\image-20240604223917027.png" alt="image-20240604223917027" /></p>
  </li>
  <li>
    <p>相比于一级页表，二级页表的开销是增大了的，但操作系统中往往使用的是二级页表而不是 一级页表。结合你自己的实验过程，说说相比于一级页表，使用二级页表会带来哪些优势。</p>

    <p>首先使用一级页表会导致所有的页表是连续存放的，需要开辟需要的空间以备使用，在进程比较多，进程页表会产生大量的连续内存开销，给操作系统内存管理带来负担；使用二级页表，由于页表是离散存放的，不需要一整片的连续内存消耗</p>

    <p>使用二级页表的话可以在需要的时候才开辟页表内存，这减少了内存消耗，比如本来需要20位的一级页表，只需要10位的页目录表就可以管理，减少了1024倍内存消耗</p>
  </li>
</ol>

<h3 id="--实验任务3-">————————- 实验任务3————————-</h3>

<h4 id="任务要求-2">任务要求：</h4>

<ol>
  <li>
    <p>复现“虚拟页内存管理”一节的代码，完成如下要求。</p>

    <ul>
      <li>结合代码分析虚拟页内存分配的三步过程和虚拟页内存释放。</li>
      <li>构造测试例子来分析虚拟页内存管理的实现是否存在bug。如果存在，则尝试修复并再次测试。否则，结合测例简要分析虚拟页内存管理的实现的正确性。</li>
      <li>在pde（页目录项）和pte（页表项）的虚拟地址构造中，我们使用了第1023个页目录项。第1023个页目录项指向了页目录表本身，从而使得我们可以构造出pde和pte的虚拟地址。现在，我们将这个指向页目录表本身的页目录项放入第1000个页目录项，而不再是放入了第1023个页目录项。然后，同学们需要借助于这个第1000个页目录项，构造出第141个页目录项的虚拟地址和第891个页目录项指向的页表中的第109个页表项的虚拟地址。</li>
      <li>（<strong>不做要求，对评分没有影响</strong>）如果你有想法，可以在自己的理解的基础上，参考ucore，《操作系统真象还原》，《一个操作系统的实现》等资料来实现自己的虚拟页内存管理。在完成之后，你需要指明相比较于本教程，你的实现的虚拟页内存管理的特点所在。</li>
    </ul>

    <p>最后将结果截图并说说你是怎么做的。</p>
  </li>
</ol>

<h4 id="结合代码分析虚拟页内存分配的三步过程和虚拟页内存释放">结合代码分析虚拟页内存分配的三步过程和虚拟页内存释放：</h4>

<p>​	在任务二的基础上我们已经实现了二级分页机制，并通过cr3寄存器开启了分页机制，之后我们的传入的虚拟地址都需要转化位物理地址才能被cpu正常访问。我们需要维护虚拟地址和物理地址的对应关系。当我们进行页内存分配时，需要分别标识虚拟地址的分配状态和物理地址的分配状态，由此而产生了两种地址池——虚拟地址池和物理地址池。当我们需要进行连续的页内存分配时</p>

<h5 id="在页分配的时候">在页分配的时候：</h5>

<ul>
  <li>在虚拟地址中分配足够的连续虚拟页；</li>
  <li>在物理地址池中为每一个虚拟地址分配相应大小的物理页；</li>
  <li>在页目录表和页表中维护对应关系（对于二级页表）；</li>
</ul>

<p>负责页内存分配的函数如下所示。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre></td><td class="rouge-code"><pre><span class="cm">/*地址管理器中的地址分配函数；
    1： 调用虚拟地址池的地址分配函数，获得连续的虚拟地址页
    2： 依次为每一个虚拟页指定物理页，循环：
    	 	从物理地址池中分配一个物理页
    		为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制变换到物理页内。
    	   	若中间产生分配失败，释放前面已经分配的虚拟页和物理页表*/</span>
<span class="kt">int</span> <span class="n">MemoryManager</span><span class="o">::</span><span class="n">allocatePages</span><span class="p">(</span><span class="k">enum</span> <span class="n">AddressPoolType</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 第一步：从虚拟地址池中分配若干虚拟页</span>
    <span class="kt">int</span> <span class="n">virtualAddress</span> <span class="o">=</span> <span class="n">allocateVirtualPages</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">virtualAddress</span><span class="p">)</span><span class="c1">//如果不是内核虚拟页，则会在这一步退出</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">flag</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">physicalPageAddress</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">vaddress</span> <span class="o">=</span> <span class="n">virtualAddress</span><span class="p">;</span>

    <span class="c1">// 依次为每一个虚拟页指定物理页</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">vaddress</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="c1">// 第二步：从物理地址池中分配一个物理页</span>
        <span class="n">physicalPageAddress</span> <span class="o">=</span> <span class="n">allocatePhysicalPages</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">physicalPageAddress</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//printf("allocate physical page 0x%x\n", physicalPageAddress);</span>
            
            <span class="c1">// 第三步：为虚拟页建立页目录项和页表项，使虚拟页内的地址经过分页机制变换到物理页内。</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="n">connectPhysicalVirtualPage</span><span class="p">(</span><span class="n">vaddress</span><span class="p">,</span> <span class="n">physicalPageAddress</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 分配失败，释放前面已经分配的虚拟页和物理页表</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 前i个页表已经指定了物理页</span>
            <span class="n">releasePages</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">virtualAddress</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="c1">// 剩余的页表未指定物理页</span>
            <span class="n">releaseVirtualPages</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">virtualAddress</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">virtualAddress</span><span class="p">;</span> 
  
    <span class="err">\</span><span class="o">*</span> <span class="err">虚拟地址分配，目前只实现了内核虚拟页，会调用虚拟地址池的分配函数</span><span class="o">*</span>\
 <span class="kt">int</span> <span class="nf">allocateVirtualPages</span><span class="p">(</span><span class="k">enum</span> <span class="n">AddressPoolType</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">kernelVrirtual</span><span class="p">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">start</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>关键是建立虚拟页和物理页的对应关系：</p>

<p>考虑一个虚拟地址virtual，变换过程如下所示。</p>

<p>构造页目录项的过程：</p>

<p>在本实验中，页目录的第1023页指向页目录，页目录作为页表的第1023个物理页指向页目录，后面的页面偏移确定虚拟地址的页表地址，等于虚拟页的页表序号乘以其大小（4B），由此得到toPDE</p>

<p>构造页表项pte的过程：pte的高10位在页目录表中查询仍然指向页目录表本身，然后中间10位在页目录表中查询指向的页表序号，也就是虚拟地址的【31：22】， 最后是在页表中查询物理页的地址，这个是虚拟地址的【21：12】，大小为32位=4B,所以乘以4</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">toPDE</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">virtualAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="mh">0xfffff000</span> <span class="o">+</span> <span class="p">(((</span><span class="n">virtualAddress</span> <span class="o">&amp;</span> <span class="mh">0xffc00000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>
<span class="p">}</span> <span class="c1">//前20位分别是查询页目录的1023个页表（也就是页目录本身），该页表的1023个页（还是页目录），最后的页内偏移获得对应页表的地址（也就是31：22的内容*4）</span>

<span class="kt">int</span> <span class="nf">toPTE</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">virtualAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="mh">0xffc00000</span> <span class="o">+</span> <span class="p">((</span><span class="n">virtualAddress</span> <span class="o">&amp;</span> <span class="mh">0xffc00000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="p">(((</span><span class="n">virtualAddress</span> <span class="o">&amp;</span> <span class="mh">0x003ff000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>
<span class="p">}</span><span class="c1">// 高10位要找页目录表在页目录表中的位置，中间10位找页表在页目录表中的位置，最后12位是物理页在该页表中的地址（注意不是序号）</span>

<span class="kt">bool</span> <span class="n">MemoryManager</span><span class="o">::</span><span class="n">connectPhysicalVirtualPage</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">virtualAddress</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">physicalPageAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 计算虚拟地址对应的页目录项和页表项</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pde</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">toPDE</span><span class="p">(</span><span class="n">virtualAddress</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">toPTE</span><span class="p">(</span><span class="n">virtualAddress</span><span class="p">);</span>

    <span class="c1">// 页目录项无对应的页表，先分配一个页表</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">pde</span> <span class="o">&amp;</span> <span class="mh">0x00000001</span><span class="p">))</span> <span class="c1">//然后检查页目录项是否有效（即最低位是否为1），如果无效则分配一个新的页表，并将页目录项指向新分配的页表。</span>
    <span class="p">{</span>
        <span class="c1">// 从内核物理地址空间中分配一个页表</span>
        <span class="kt">int</span> <span class="n">page</span> <span class="o">=</span> <span class="n">allocatePhysicalPages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="c1">// 使页目录项指向页表</span>
        <span class="o">*</span><span class="n">pde</span> <span class="o">=</span> <span class="n">page</span> <span class="o">|</span> <span class="mh">0x7</span><span class="p">;</span>
        <span class="c1">// 初始化页表</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">pagePtr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">int</span><span class="p">)</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffff000</span><span class="p">);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">pagePtr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 使页表项指向物理页</span>
    <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">physicalPageAddress</span> <span class="o">|</span> <span class="mh">0x7</span><span class="p">;</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="页内存释放">页内存释放</h5>

<p>但我们在分配页内存时，如果遇到物理页无法分配的情况，之前成功分配的虚拟页和物理页都要释放。否则就会造成内存泄漏，这部分内存无法再被分配。</p>

<p>页内存的释放是页内存分配的过程，分两个步骤完成。</p>

<ul>
  <li>对每一个虚拟页，释放为其分配的物理页。</li>
  <li>释放虚拟页。</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="n">MemoryManager</span><span class="o">::</span><span class="n">releasePages</span><span class="p">(</span><span class="k">enum</span> <span class="n">AddressPoolType</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">virtualAddress</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="n">virtualAddress</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pte</span><span class="p">,</span> <span class="o">*</span><span class="n">pde</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">flag</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">ENTRY_NUM</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">vaddr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">releasePhysicalPages</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">vaddr2paddr</span><span class="p">(</span><span class="n">vaddr</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>

        <span class="c1">// 设置页表项为不存在，防止释放后被再次使用</span>
        <span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">toPTE</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span><span class="c1">//由于指向的物理页已经不存在，所以需要标记为不可用</span>
        <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">releaseVirtualPages</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">virtualAddress</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">MemoryManager</span><span class="o">::</span><span class="n">vaddr2paddr</span><span class="p">(</span><span class="kt">int</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">toPTE</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">page</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffff000</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vaddr</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">page</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MemoryManager</span><span class="o">::</span><span class="n">releaseVirtualPages</span><span class="p">(</span><span class="k">enum</span> <span class="n">AddressPoolType</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">vaddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">kernelVirtual</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="构造测试例子来分析虚拟页内存管理的实现是否存在bug">构造测试例子来分析虚拟页内存管理的实现是否存在bug</h5>

<p>​		分别分配5，100，10的物理页的3个内存，然后释放100的物理页，最后创建两个10的物理页；</p>

<p>​	1， 查看虚拟页是否是连续的，二级页表下对应的物理页是否可以是离散的；</p>

<p>​	2， 查看释放后的虚拟页和物理页是否是可被再利用的。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">first_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%x %x %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">);</span>

    <span class="n">memoryManager</span><span class="p">.</span><span class="n">releasePages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">p2</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p4</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p4</span><span class="p">);</span>

    <span class="kt">char</span> <span class="o">*</span><span class="n">p5</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    
    <span class="n">printf</span><span class="p">(</span><span class="s">"%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p5</span><span class="p">);</span>

    <span class="n">asm_halt</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="..\img\in-post\image-20240603113306570.png" alt="image-20240603113306570" /></p>

<p><img src="..\img\in-post\image-20240603113401005.png" alt="image-20240603113401005" /></p>

<p>​</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>P1:5</th>
      <th>P2:100</th>
      <th>P3:10</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>虚拟页开始</td>
      <td>C010_0000h</td>
      <td>C010_5000h</td>
      <td>C016_9000h</td>
    </tr>
    <tr>
      <td>物理页开始</td>
      <td>0020_0000h</td>
      <td>0020_5000h</td>
      <td>0026_9000h</td>
    </tr>
  </tbody>
</table>

<p><img src="..\img\in-post\image-20240603113854013.png" alt="image-20240603113854013" /></p>

<p><img src="..\img\in-post\image-20240603113936978.png" alt="image-20240603113936978" /></p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>P1:5</th>
      <th>P2:100(已经释放)</th>
      <th>P3:10</th>
      <th>P4:10</th>
      <th>P5:10</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>虚拟页开始</td>
      <td>C010_0000h</td>
      <td>C010_5000h</td>
      <td>C016_9000h</td>
      <td>C010_5000h</td>
      <td>C010_F000h</td>
    </tr>
    <tr>
      <td>物理页开始</td>
      <td>0020_0000h</td>
      <td>0020_5000h</td>
      <td>0026_9000h</td>
      <td>0020_5000h</td>
      <td>0020_F000h</td>
    </tr>
  </tbody>
</table>

<p>​	从以上测试可以看出，虚拟内存页是连续的，而在虚拟页和物理页释放以后，相应的空间可以被再利用。</p>

<h5 id="在pde页目录项和pte页表项的虚拟地址构造中我们使用了第1023个页目录项第1023个页目录项指向了页目录表本身从而使得我们可以构造出pde和pte的虚拟地址现在我们将这个指向页目录表本身的页目录项放入第1000个页目录项而不再是放入了第1023个页目录项"><strong>在pde（页目录项）和pte（页表项）的虚拟地址构造中，我们使用了第1023个页目录项。第1023个页目录项指向了页目录表本身，从而使得我们可以构造出pde和pte的虚拟地址。现在，我们将这个指向页目录表本身的页目录项放入第1000个页目录项，而不再是放入了第1023个页目录项。、</strong></h5>

<h5 id="然后同学们需要借助于这个第1000个页目录项构造出第141个页目录项的虚拟地址和第891个页目录项指向的页表中的第109个页表项的虚拟地址"><strong>然后，同学们需要借助于这个第1000个页目录项，构造出第141个页目录项的虚拟地址和第891个页目录项指向的页表中的第109个页表项的虚拟地址。</strong></h5>

<p>​	首先需要将页目录表放在页目录表中的1000处；</p>

<p>​	然后修改PDE, PTE的计算方法：</p>

<p>​		对于PDE, 其高10位是页目录表在页目录表中的位置，也就是1000，16进制为0x3e8乘以4得到地址为0xFA0,中间10位也是页目录表作为页表的位置所以也是0xFA0, 最后的是页表作为页内偏移在页目录表中的地址，是高10位乘以4；</p>

<p>​		对于PTE, 其高10位仍然是页目录表在页目录表中的位置0xFA0，中间10位是页表作为页目录项在页目录中的位置是virtua[31:22], 低12位是页表项作为物理页在页表中的页内偏移，也就是virtual[21:12]左移4位；</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">toPDE</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">virtualAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="mh">0xfa0fa000</span> <span class="o">+</span> <span class="p">(((</span><span class="n">virtualAddress</span> <span class="o">&amp;</span> <span class="mh">0xffc00000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">22</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>
<span class="p">}</span> <span class="c1">//在下面的计算中，141相当于(virtualAddress &amp; 0xffc00000) &gt;&gt; 22) 的输出</span>

<span class="kt">int</span> <span class="nf">toPTE</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">virtualAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="mh">0xfa000000</span> <span class="o">+</span> <span class="p">((</span><span class="n">virtualAddress</span> <span class="o">&amp;</span> <span class="mh">0xffc00000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="p">(((</span><span class="n">virtualAddress</span> <span class="o">&amp;</span> <span class="mh">0x003ff000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>
    <span class="c1">//在下面的计算中，891相当于((virtualAddress &amp; 0xffc00000) &gt;&gt; 10)，109相当于((virtualAddress &amp; 0x003ff000) &gt;&gt; 12)的输出</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h5 id="计算结果">计算结果：</h5>

<p>​	那么对于页目录中的第141(0x8D)个页目录项，其虚拟地址是0xfa0fa08d0;</p>

<p>​	对于第891(0x37B)个页目录项指向的页表中的第109(0x6d)个页表项的虚拟地址，是0xfa037b6d0;</p>

<h3 id="--实验任务4--">————————- <em>实验任务</em>4 ————————-</h3>

<h4 id="任务要求-3">任务要求：</h4>

<p>选做内容，如果完成，可附加实验完成度评分）在Assignment 3的基础上，实现一种理论课上 学习到的虚拟内存管理中的页面置换算法，在虚拟页内存中实现页面的置换，比如下面所列算法 的其中一种:</p>

<ol>
  <li>先进先出页面置换(FIFO).</li>
  <li>最优页面置换(OPR).</li>
  <li>最近最少使用页面置换(LRU)</li>
  <li>最不经常使用页面置换(LFU)。</li>
</ol>

<p>上述置换算法的细节参见理论课教材(《操作系统概念》，原书第9版，中文)第272-280页，你也 可以实现一种自己设计的置换算法。要求:描述你的设计思路并展示页面置换结果的截图(也可以 统计缺页错误发生的次数作为输出）。</p>

<p>​	<strong>本实验尝试实现FIFO算法</strong></p>

<h4 id="思路分析-1">思路分析：</h4>

<p>​	维护一个队列，当物理页（虚拟页）不够的时候，将这个队列的队首页置换为新的页</p>

<p>​	<strong>由于在本实验虚拟页是从低处到高处连续分配的</strong>，实际上，可以简单地使用一个指针指向最早分配的虚拟页地址， 在内存页不够的时候（缺页），将这个指针所指向的虚拟页回收，指向这个虚拟页的下一个虚拟页，不断重复知道获得足够的空内存页，然后分配给进程。注意本实验中虚拟页可用总数为15984个，所以可以分配一个15900的虚拟页给进程，然后开展后续的测试；</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">second_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>   
    <span class="kt">char</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">15900</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p3</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">p4</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">memoryManager</span><span class="p">.</span><span class="n">allocatePages</span><span class="p">(</span><span class="n">AddressPoolType</span><span class="o">::</span><span class="n">KERNEL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"%x %x %x %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p1</span><span class="p">);</span>

    <span class="n">asm_halt</span><span class="p">();</span>
<span class="p">}</span>


</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>
    <span class="k">class</span> <span class="nc">MemoryManager</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// 可管理的内存容量</span>
    <span class="kt">int</span> <span class="n">totalMemory</span><span class="p">;</span>
    <span class="c1">// 内核物理地址池</span>
    <span class="n">AddressPool</span> <span class="n">kernelPhysical</span><span class="p">;</span>
    <span class="c1">// 用户物理地址池</span>
    <span class="n">AddressPool</span> <span class="n">userPhysical</span><span class="p">;</span>
    <span class="c1">// 内核虚拟地址池</span>
    <span class="n">AddressPool</span> <span class="n">kernelVirtual</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">virtual_pages</span><span class="p">;</span> <span class="c1">//记录最早分配的虚拟页，在初始化函数中被初始化为kernel_virtual_strat,也就是0xC0100000</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>
<span class="kt">int</span> <span class="n">MemoryManager</span><span class="o">::</span><span class="n">allocatePages</span><span class="p">(</span><span class="k">enum</span> <span class="n">AddressPoolType</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 第一步：从虚拟地址池中分配若干虚拟页</span>
    <span class="k">if</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span><span class="mi">15984</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"No enougn pages in total!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">//物理页总数不够，没办法</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">virtualAddress</span> <span class="o">=</span> <span class="n">allocateVirtualPages</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> <span class="c1">//尝试分配内存页</span>
    <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">virtualAddress</span><span class="p">){</span>
        <span class="n">releasePages</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">virtual_pages</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">virtual_pages</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">virtual_pages</span> <span class="o">==</span> <span class="p">(</span><span class="mh">0x3e71000</span><span class="o">+</span><span class="mh">0xC0100000</span><span class="p">))</span> <span class="c1">//0x3E700是第15984页的末地址</span>
            <span class="n">virtual_pages</span> <span class="o">=</span> <span class="n">KERNEL_VIRTUAL_START</span><span class="p">;</span>
        <span class="n">virtualAddress</span> <span class="o">=</span> <span class="n">allocateVirtualPages</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> 
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"the first virtual page to exchange is 0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">virtual_pages</span><span class="p">);</span> 
    <span class="c1">//打印准备抛弃的虚拟页</span>
    
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="成果展示">成果展示：</h4>

<p><img src="..\img\in-post\image-20240604154133439.png" alt="image-20240604154133439" /></p>

<p>​	可以看到第一个线程使用15900个页，在0xc010000开始；</p>

<p>​	第二个线程请求10个页，这时候没有发生页错误（存在连续的10个页），所以第二个线程的开始是0xc3f1c000;</p>

<p>​	第三个线程请求10个页，发生缺页错误，需要抛弃第一个线程的10个页，所以按照FIFO的规则，抛弃第一个线程的10个页，这个时候指针来到0xc016400（起始加10页），</p>

<p>​	最后一个线程类似第三个线程，依然要抛弃10个页；</p>



                    
                    <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img
                            alt="Creative Commons License"
                            style="border-width:0;max-width: 40%;margin-left: 0px;margin-bottom: 5px;"
                            src="/img/icons/cc_byncsa.flat.guokr.svg" /></a><text style="font-size: 14px">本作品采用<a
                            rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享
                            4.0
                            国际许可协议</a>进行许可。<br />This work is licensed under a <a rel="license"
                            href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons
                            Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</text><br />
                    

                    <hr style="visibility: hidden;">
                    <ul class="pager">
                        
                        <li class="previous">
                            <a href="/2024-05-19-OS-lab6/"
                                data-toggle="tooltip" data-placement="top" title="OS lab6 实现自旋锁，信号量">
                                Previous<br>
                                <span>OS lab6 实现自旋锁，信号量</span>
                            </a>
                        </li>
                        
                        
                        <li class="next">
                            <a href="/2024-06-21-OS-lab8/"
                                data-toggle="tooltip" data-placement="top" title="OS lab8 从内核态到用户态">
                                Next<br>
                                <span>OS lab8 从内核态到用户态</span>
                            </a>
                        </li>
                        
                    </ul>
                    <hr style="visibility: hidden;">

                    <!--Gitalk评论start  -->
                    
                    <!-- Gitalk end -->

                    

                    
                </div>

                <!-- Side Catalog Container -->
                
                <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                    <div class="side-catalog">
                        <hr class="hidden-sm hidden-xs">
                        <h5>
                            <a class="catalog-toggle" href="#">CATALOG</a>
                        </h5>
                        <ul class="catalog-body"></ul>
                    </div>
                </div>
                

                <!-- Sidebar Container -->
                <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">
                    <!-- DONE: FRIEND has a link to the last tag -->

                    <!-- Featured Tags -->
                    


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
        
                <a data-sort="0009" 
                    href="/archive/?tag=OS"
                    title="OS"
                    rel="7">OS</a>
        
                <a data-sort="0009" 
                    href="/archive/?tag=HPC"
                    title="HPC"
                    rel="7">HPC</a>
    </div>
</section>


                    <!-- Friends Blog -->
                    
                </div>
            </div>
        </div>
</article>

<!-- add support for mathjax by voleking-->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    SVG: {
      scale: 90
    },
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      displayMath: [ ['$$','$$'], ['\\[','\\]'], ['\\(','\\)'] ],
      processEscapes: true,
    }
  });
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG">
</script>


<!-- CleverYh -->

<!-- End CleverYh -->








<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js", function () {
        anchors.options = {
            visible: 'hover',
            placement: 'right',
            // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link {
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top: -0.1em;
        }
    }
</style>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">
    

        
        
        
        
        <li>
            <a target="_blank" title="Github" href="https://github.com/luohj29">
                <!-- <span class="fa-stack fa-lg">
                    <i class="fa fa-circle fa-stack-2x"></i>
                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span> -->
                <span class="fa-stack fa-lg">
                    <i class="fa-brands fa-github-alt fa-stack-1x"></i>
                </span>
            </a>
        </li>
        
        
        
        
        
        
        
        
    </ul>

                <p class="copyright text-muted">
                    <text style="opacity: 1; color: #007799;">&copy; 2019 - 2025 <a
                            href="https://luohj29.github.io/">RogersLuo's Blog</a>
                    </text><br>
                    <span style="opacity: 0.78; color: #007799;font-family: 'CamingoCodeRegular';">
                        <!-- Default Statcounter code for lzzmm
                    https://lzzmm.github.io -->
                        <script type="text/javascript">
                            var sc_project = 12680417;
                            var sc_invisible = 0;
                            var sc_security = "74b5722d";
                            var sc_text = 2;
                            var scJsHost = "https://";
                            document.write("<script type='text/javascript' src='" +
                                scJsHost +
                                "statcounter.com/counter/counter.js'></" + "script>");
                        </script>
                        <!-- <noscript>
                        <div class="statcounter"><a title="Web Analytics" href="https://statcounter.com/" target="_blank"><img
                                    class="statcounter" src="https://c.statcounter.com/12680417/0/74b5722d/0/" alt="Web Analytics"
                                    referrerPolicy="no-referrer-when-downgrade"></a></div>
                        </noscript> -->
                        <!-- End of Statcounter Code -->
                        <span> visits | </span>
                        <span>Uptime:</span><span id="display_live_time"></span>
                        <script>function blog_live_time() {
                                window.setTimeout(blog_live_time, 1000);
                                const start = new Date('2020-02-16T14:37:00');
                                const now = new Date();
                                const timeDiff = (now.getTime() - start.getTime());
                                const msPerMinute = 60 * 1000;
                                const msPerHour = 60 * msPerMinute;
                                const msPerDay = 24 * msPerHour;
                                const passDay = Math.floor(timeDiff / msPerDay);
                                const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
                                const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
                                const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
                                display_live_time.innerHTML = " " + passDay + "d " + passHour + "h " + passMinute + "m " + passSecond + "s ";
                            }
                            blog_live_time();
                        </script>
                    </span><br>
                    <text style="opacity: 0.66; color: #0099bb;">Powered by <a
                            href="https://github.com/luohj29/luohj29.github.io"
                            target="_blank">luohj29.github.io</a> |
                        <iframe style="margin-left: 2px; margin-right: -20px; margin-bottom:-5px; opacity: 0.55;"
                            frameborder="0" scrolling="0" width="100px" height="20px"
                            src="https://ghbtns.com/github-btn.html?user=luohj29&repo=luohj29.github.io&type=star&count=true">
                        </iframe></text><br>
                    <text style="opacity: 0.6; font-size: 13px;">Improved from the theme by <a
                            href="http://huangxuan.me/" target="_blank">Hux Blog</a></text>
                    <!-- </text> -->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src=" /js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src=" /js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src=" /js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src=" /js/snackbar.js "></script>
<script src=" /js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->





<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog(selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->



    <!-- Image to hack wechat -->
    <img src="/img/icon_wechat.png" width="0" height="0" />
    <!-- Migrate from head to bottom, no longer block render and still work -->
</body>

</html>